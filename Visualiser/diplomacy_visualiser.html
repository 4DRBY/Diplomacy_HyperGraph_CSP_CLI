<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diplomacy Hypergraph Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0; }
        .province text { fill: #a0aec0; font-size: 10px; font-weight: 500; text-anchor: middle; pointer-events: none; }
        .adjacency-line { stroke: #4a5568; stroke-width: 1.5px; }
        .province-node { stroke: #4a5568; stroke-width: 2px; fill: #2d3748; }
        .sc-node { stroke: #cbd5e0; stroke-width: 2px; fill: #2d3748; }
        .order-arrow { stroke-width: 2.5px; opacity: 0.85; }
        .arrow-head { fill-opacity: 0.85; }
        .order-hold { stroke-width: 3px; fill: none; opacity: 0.9; }
        .order-support { stroke-width: 2px; stroke-dasharray: 4 2; opacity: 0.9; }
        .order-support-invalid { stroke: #e53e3e; stroke-width: 2px; stroke-dasharray: 2 2; opacity: 0.7; }
        .unit-shape { stroke-width: 2px; stroke: #1a202c; }
        .result-marker { font-size: 24px; font-weight: bold; text-anchor: middle; paint-order: stroke; stroke: #1a202c; stroke-width: 3px; }
        .tooltip { position: absolute; text-align: center; padding: 8px; font-size: 12px; background: #4a5568; color: #f7fafc; border: 0px; border-radius: 8px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .status-connected { background-color: #48bb78; }
        .status-disconnected { background-color: #e53e3e; }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-7xl bg-gray-800 rounded-xl shadow-2xl p-6 border border-gray-700">
        <div class="flex justify-between items-center mb-2">
            <h1 class="text-2xl font-bold text-white">Diplomacy Turn Resolution</h1>
            <div id="connection-status" class="flex items-center text-sm">
                <span id="status-dot" class="status-dot status-disconnected"></span>
                <span id="status-text">Disconnected</span>
            </div>
        </div>
        <p id="subtitle" class="text-center text-gray-400 mb-6">Attempting to connect to Python engine...</p>
        
        <div id="visualization" class="w-full h-[70vh] rounded-lg bg-gray-900 border border-gray-700 overflow-hidden relative"></div>
        <div class="tooltip"></div>
        
        <div id="legend" class="flex flex-wrap gap-x-6 gap-y-2 text-sm text-gray-400 mt-6">
             <div><span class="inline-block w-3 h-3 bg-gray-800 border-2 border-gray-400 rounded-full mr-2 align-middle"></span>Supply Center</div>
            <div><span class="inline-block w-3 h-3 bg-gray-800 border-2 border-gray-700 rounded-full mr-2 align-middle"></span>Province</div>
            <div class="flex items-center"><svg width="20" height="10" class="mr-2"><line x1="0" y1="5" x2="20" y2="5" class="order-arrow" stroke="#9f7aea"></line></svg>Move</div>
            <div class="flex items-center"><svg width="20" height="10" class="mr-2"><line x1="0" y1="5" x2="20" y2="5" class="order-support" stroke="#ed8936"></line></svg>Support</div>
            <div class="flex items-center"><svg width="20" height="10" class="mr-2"><circle cx="10" cy="5" r="4" class="order-hold" stroke="#48bb78"></circle></svg>Hold</div>
        </div>
    </div>

<script>
    // --- GLOBAL STATE ---
    let provinces = {};
    let units = [];
    let currentTurnOrders = [];
    let simulation;
    const nationColors = {'France': '#6366f1', 'Germany': '#a0aec0', 'England': '#e53e3e'};
    const orderColors = {'Move': '#9f7aea', 'Support': '#ed8936', 'Hold': '#48bb78', 'Success': '#38a169', 'Fail': '#e53e3e', 'Cut': '#f56565'};
    
    // --- D3 SETUP ---
    const container = d3.select("#visualization");
    const tooltip = d3.select(".tooltip");
    let width = container.node().getBoundingClientRect().width;
    let height = container.node().getBoundingClientRect().height;
    const svg = container.append("svg").attr("width", width).attr("height", height);
    svg.append('defs').append('marker').attr('id', 'arrow').attr('viewBox', '0 -5 10 10')
        .attr('refX', 8).attr('refY', 0).attr('markerWidth', 6).attr('markerHeight', 6)
        .attr('orient', 'auto').append('path').attr('d', 'M0,-5L10,0L0,5').attr('class', 'arrow-head');
    const g = svg.append("g");
    const zoom = d3.zoom().scaleExtent([0.5, 5]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);

    // --- WEBSOCKET CLIENT ---
    const wsHost = window.location.hostname || "localhost";
    const wsUrl = `ws://${wsHost}:8765`;
    
    function connect() {
        console.log(`Attempting to connect to WebSocket at: ${wsUrl}`);
        d3.select("#subtitle").text(`Attempting to connect to Python engine at ${wsUrl}...`);
        
        const socket = new WebSocket(wsUrl);

        socket.onopen = function(e) {
            console.log("Connection established with Python engine.");
            d3.select("#status-dot").attr("class", "status-dot status-connected");
            d3.select("#status-text").text("Connected");
            d3.select("#subtitle").text("Connection successful. Waiting for turn data...");
        };

        socket.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                console.log("Data received from Python:", data);
                handleMessage(data);
            } catch (e) {
                console.error("Error processing message:", e);
                d3.select("#subtitle").text(`Error rendering game state: ${e.message}`);
            }
        };

        socket.onclose = function(event) {
            console.log("WebSocket connection closed.");
            d3.select("#status-dot").attr("class", "status-dot status-disconnected");
            d3.select("#status-text").text("Disconnected");
            d3.select("#subtitle").html(`Connection closed. Restart the Python server and <a href="." class="text-indigo-400 hover:underline">refresh this page</a> to reconnect.`);
        };

        socket.onerror = function(error) {
            console.error(`WebSocket Error:`, error);
            d3.select("#status-dot").attr("class", "status-dot status-disconnected");
            d3.select("#status-text").text("Connection Failed");
            d3.select("#subtitle").html(`Could not connect to the Python engine at ${wsUrl}.<br/>Please ensure the Python server is running and check the browser console (F12) for errors.`);
        };
    }

    function handleMessage(data) {
        switch(data.type) {
            case 'initial_state':
                provinces = data.provinces;
                units = data.units;
                currentTurnOrders = [];
                d3.select("#subtitle").text(`Connected. Current turn: ${data.season} ${data.year}.`);
                initializeForceSimulation(Object.values(provinces), data.adjacencies, data.centralProvinceId);
                break;
            case 'turn_update':
                units = data.units;
                currentTurnOrders = [];
                d3.select("#subtitle").text(`Starting turn: ${data.season} ${data.year}. View terminal to input orders.`);
                g.selectAll(".orders, .units, .result-marker").remove();
                drawUnits();
                break;
            case 'add_order':
                currentTurnOrders.push(data.order);
                drawOrders(currentTurnOrders);
                break;
            case 'adjudication_result':
                updateVisualization(data.results, data.details);
                break;
            case 'game_over':
                d3.select("#subtitle").text("Game Over. The connection has been closed.");
                break;
        }
    }

    // --- RENDERING & VISUALIZATION (REWRITTEN FOR FORCE-DIRECTED LAYOUT) ---
    function initializeForceSimulation(provinceNodes, adjacencyLinks, centralProvinceId) {
        // *** FIX: Anchor the layout around the most connected province ***
        const centralNode = provinceNodes.find(p => p.id === centralProvinceId);
        if (centralNode) {
            centralNode.fx = width / 2;
            centralNode.fy = height / 2;
        }

        const links = adjacencyLinks.map(d => ({...d}));
        
        simulation = d3.forceSimulation(provinceNodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(120).strength(0.5))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("x", d3.forceX(width / 2).strength(0.05)) // A gentle pull to the center
            .force("y", d3.forceY(height / 2).strength(0.05));

        g.select(".links").remove();
        const link = g.append("g").attr("class", "links")
            .selectAll("line").data(links).join("line").attr("class", "adjacency-line");

        g.select(".nodes").remove();
        const node = g.append("g").attr("class", "nodes")
            .selectAll("g").data(provinceNodes).join("g").attr("class", "province");
            
        node.append("circle")
            .attr("r", d => d.is_supply_center ? 12 : 10)
            .attr("class", d => d.is_supply_center ? 'sc-node' : 'province-node');

        node.append("text").attr("y", -18).text(d => d.name);
        
        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            node.attr("transform", d => `translate(${d.x},${d.y})`);
            
            drawUnits();
            drawOrders(currentTurnOrders);
        });
    }
    
    function getProvinceNode(provinceId) {
        if (!simulation) return null;
        return simulation.nodes().find(p => p.id === provinceId);
    }

    function drawUnits() {
        if (!simulation) return;
        g.select(".units").remove();
        g.append("g").attr("class", "units")
            .selectAll("g.unit-group").data(units, d => d.id)
            .join(enter => {
                const unitEl = enter.append("g").attr("class", "unit-group").attr("id", d => `unit-vis-${d.id}`);
                unitEl.append("rect").attr("x", -7.5).attr("y", -7.5).attr("width", 15).attr("height", 15)
                    .attr("class", "unit-shape").style("fill", d => nationColors[d.nationality]);
                unitEl.on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(`<b>${d.id}</b><br/>${d.nationality} ${d.type}`)
                        .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px");
                }).on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
                return unitEl;
            })
            .attr("transform", d => {
                const provinceNode = getProvinceNode(d.location);
                return provinceNode ? `translate(${provinceNode.x}, ${provinceNode.y})` : null;
            });
    }

    function drawOrders(orders) {
        if (!simulation) return;
        g.select(".orders").remove();
        const orderGroup = g.append("g").attr("class", "orders");

        orderGroup.selectAll("g.order-vis-group").data(orders, d => d.id)
            .join(enter => {
                const orderEl = enter.append("g").attr("class", "order-vis-group").attr("id", d => `order-vis-${d.id}`);
                orderEl.filter(d => d.type === 'Hold').append("circle").attr("class", "order-hold").attr("stroke", orderColors.Hold);
                orderEl.filter(d => d.type === 'Move').append("line").attr("class", "order-arrow").attr("stroke", orderColors.Move).attr("marker-end", "url(#arrow)");
                orderEl.filter(d => d.type === 'Support').append("line")
                    .attr("class", d => d.is_valid_support ? "order-support" : "order-support-invalid")
                    .attr("stroke", d => d.is_valid_support ? orderColors.Support : orderColors.Fail);
            });

        orderGroup.selectAll(".order-hold").attr("cx", d => getProvinceNode(d.unit.location)?.x)
            .attr("cy", d => getProvinceNode(d.unit.location)?.y).attr("r", 20);
        orderGroup.selectAll(".order-arrow")
            .attr("x1", d => getProvinceNode(d.unit.location)?.x)
            .attr("y1", d => getProvinceNode(d.unit.location)?.y)
            .attr("x2", d => getProvinceNode(d.to_province_id)?.x)
            .attr("y2", d => getProvinceNode(d.to_province_id)?.y);
        orderGroup.selectAll(".order-support, .order-support-invalid")
            .each(function(d) {
                const startNode = getProvinceNode(d.unit.location);
                if (!startNode) { d3.select(this).remove(); return; }
                let targetPos = { x: startNode.x, y: startNode.y - 15 };
                if (d.is_valid_support) {
                    const supportedStart = getProvinceNode(d.supported_action_start_loc);
                    const supportedEnd = getProvinceNode(d.supported_action_end_loc);
                    if (supportedStart && supportedEnd) {
                        targetPos = { x: (supportedStart.x + supportedEnd.x) / 2, y: (supportedStart.y + supportedEnd.y) / 2 };
                    }
                }
                d3.select(this).attr("x1", startNode.x).attr("y1", startNode.y)
                    .attr("x2", targetPos.x).attr("y2", targetPos.y);
            });
    }

    function updateVisualization(results, details) {
        Object.entries(results).forEach(([unitId, outcome]) => {
            const order = currentTurnOrders.find(o => o.unit.id === unitId);
            if (!order) return;
            
            const orderVis = d3.select(`#order-vis-${order.id}`);
            const success = (outcome === 'moves' || outcome === 'stands');
            const supportStatus = details.support_statuses[order.id];

            if (!orderVis.empty()) {
                let finalColor = success ? orderColors.Success : orderColors.Fail;
                if (order.type === 'Support' && supportStatus === 'cut') {
                    finalColor = orderColors.Cut;
                }
                orderVis.selectAll("line, circle").transition().duration(500).attr("stroke", finalColor);
            }

            const unitVis = d3.select(`#unit-vis-${unitId}`);
            if (outcome === 'moves') {
                const endNode = getProvinceNode(order.to_province_id);
                if (endNode) {
                    unitVis.transition().duration(1000).delay(200)
                        .attr("transform", `translate(${endNode.x}, ${endNode.y})`);
                }
            } else if (outcome === 'stands' && order.type === 'Move') {
                const startNode = getProvinceNode(order.unit.location);
                const endNode = getProvinceNode(order.to_province_id);
                if (startNode && endNode) {
                    g.append("text").attr("class", "result-marker")
                        .attr("x", (startNode.x + endNode.x) / 2).attr("y", (startNode.y + endNode.y) / 2 + 8)
                        .style("fill", orderColors.Fail).text("✕").style("opacity", 0)
                        .transition().duration(500).delay(500).style("opacity", 1);
                }
            }
        });
    }
    
    window.addEventListener('resize', () => {
        width = container.node().getBoundingClientRect().width;
        height = container.node().getBoundingClientRect().height;
        svg.attr("width", width).attr("height", height);
        if (simulation) {
            const centralNode = simulation.nodes().find(n => n.id === centralProvinceId);
            if(centralNode) {
                centralNode.fx = width / 2;
                centralNode.fy = height / 2;
            }
            simulation.alpha(0.3).restart(); // Give the simulation a boost to rearrange
        }
    });

    connect();

</script>

</body>
</html>